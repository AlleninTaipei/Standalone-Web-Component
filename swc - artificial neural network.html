<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ANN Training Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/17.0.2/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/17.0.2/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }

        #root {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>

<body>
    <div id="root"></div>
    <script type="text/babel">
        const ANNTrainingAnimation = () => {
            const [epoch, setEpoch] = React.useState(0);
            const [phase, setPhase] = React.useState('forward');
            const [activeLayer, setActiveLayer] = React.useState(0);

            const layers = [3, 4, 4, 2];
            const nodeRadius = 20;
            const layerSpacing = 150;
            const nodeSpacing = 60;

            React.useEffect(() => {
                const interval = setInterval(() => {
                    if (phase === 'forward') {
                        if (activeLayer < layers.length - 1) {
                            setActiveLayer(activeLayer + 1);
                        } else {
                            setPhase('backward');
                            setActiveLayer(layers.length - 2);
                        }
                    } else {
                        if (activeLayer > 0) {
                            setActiveLayer(activeLayer - 1);
                        } else {
                            setPhase('forward');
                            setActiveLayer(1);
                            setEpoch(epoch + 1);
                        }
                    }
                }, 1000);

                return () => clearInterval(interval);
            }, [phase, activeLayer, epoch]);

            const renderLayer = (layerIndex, layerSize) => {
                return Array(layerSize).fill().map((_, nodeIndex) => {
                    const x = layerIndex * layerSpacing + 50;
                    const y = (nodeIndex - (layerSize - 1) / 2) * nodeSpacing + 200;
                    const isActive = layerIndex === activeLayer ||
                        (phase === 'forward' && layerIndex === activeLayer - 1) ||
                        (phase === 'backward' && layerIndex === activeLayer + 1);

                    return (
                        <g key={`node-${layerIndex}-${nodeIndex}`}>
                            <circle
                                cx={x}
                                cy={y}
                                r={nodeRadius}
                                fill={isActive ? 'rgba(0, 123, 255, 0.8)' : 'rgba(0, 123, 255, 0.3)'}
                                stroke="black"
                                strokeWidth="2"
                            />
                            {layerIndex < layers.length - 1 && Array(layers[layerIndex + 1]).fill().map((_, nextNodeIndex) => {
                                const nextX = (layerIndex + 1) * layerSpacing + 50;
                                const nextY = (nextNodeIndex - (layers[layerIndex + 1] - 1) / 2) * nodeSpacing + 200;
                                const isActiveConnection = (phase === 'forward' && layerIndex === activeLayer - 1) ||
                                    (phase === 'backward' && layerIndex === activeLayer);
                                return (
                                    <line
                                        key={`connection-${layerIndex}-${nodeIndex}-${nextNodeIndex}`}
                                        x1={x + nodeRadius}
                                        y1={y}
                                        x2={nextX - nodeRadius}
                                        y2={nextY}
                                        stroke={isActiveConnection ? 'rgba(255, 0, 0, 0.8)' : 'rgba(0, 0, 0, 0.2)'}
                                        strokeWidth={isActiveConnection ? 3 : 1}
                                    />
                                );
                            })}
                        </g>
                    );
                });
            };

            return (
                <div style={{ width: '100%', height: '500px', backgroundColor: '#f8f9fa', borderRadius: '8px', overflow: 'hidden' }}>
                    <svg width="100%" height="100%" viewBox="0 0 600 400">
                        {layers.map((layerSize, index) => renderLayer(index, layerSize))}
                        <text x="50" y="50" fontWeight="bold">Input Layer</text>
                        <text x="200" y="50" fontWeight="bold">Hidden Layer 1</text>
                        <text x="350" y="50" fontWeight="bold">Hidden Layer 2</text>
                        <text x="500" y="50" fontWeight="bold">Output Layer</text>
                        <text x="50" y="380" fontWeight="bold">{`Epoch: ${epoch}`}</text>
                        <text x="200" y="380" fontWeight="bold">{`Phase: ${phase === 'forward' ? 'Forward Pass' : 'Backward Pass'}`}</text>
                    </svg>
                </div>
            );
        };

        ReactDOM.render(<ANNTrainingAnimation />, document.getElementById('root'));
    </script>
</body>

</html>